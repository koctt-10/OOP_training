ООП(объектно ориентированное программирование) - подход/концепция программирования. 
Согласно данному подходу представляет собой некоторую систему взаимодействующих объектов.

# Определение класса
class Cat:
    # Конструктор класса
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # Метод класса
    def meow(self):
        print(f"{self.name} говорит: Мяу!")

# Создание экземпляра класса
my_cat = Cat("Барсик", 3)

# Доступ к атрибутам экземпляра и вызов метода
print(f"{my_cat.name} возраст {my_cat.age} года.")
my_cat.meow()

Объект - единица информации в памяти(цифровая сущность, обладающая некоторыми св-вами(атрибутами)
и поведением, определённым посредством некоторых методов).

Экземпляр - конкретный объект какого-то класса.
Класс - инструкция по созданию объекта определённого типа.
Метод - функция в классе для воздействия на объект.
Поля или свойства - переменные в классе.
Атрибуты - все имена в классе: переменных или методов.

Абстракция – процесс определения существенных характеристик объекта и игнорирования несущественных характеристик.
Это позволяет создавать абстрактные классы, которые определяют общие свойства и поведение группы объектов, не уточняя детали каждого объекта.

Полиморфизм - способность объектов принимать различные формы.
В ООП полиморфизм позволяет рассматривать объекты разных классов так, как если бы они были объектами одного класса.

Инкапсуляция – механизм сокрытия деталей реализации класса от других объектов.
Достигается путем использования модификаторов доступа public, private и protected, которые соответствуют публичным, приватным и защищенным атрибутам.



__init__ — это специальная функция, которая вызывается при создании нового объекта класса.
__del__— это специальная функция, которая вызывается при удалении нового объекта класса.

1. Инкапсуляция:
Инкапсуляция ограничивает доступ к членам класса. В Python члены класса могут быть обозначены как публичные, защищенные и приватные с помощью конвенции именования:
- Публичные члены обозначаются без префикса
- Защищенные члены начинаются с одного подчеркивания ('_')
- Приватные члены начинаются с двух подчеркиваний ('__')

2. Наследование:
Наследование позволяет создавать новый класс на основе существующего, наследуя его свойства и методы.
Пример:
   class Animal:
       def __init__(self, name):
           self.name = name

   class Dog(Animal):
       def speak(self):
           return "Гав!"

   my_dog = Dog("Барсик")
   print(my_dog.name)  # Выведет "Барсик"
   


3. Полиморфизм:
Полиморфизм позволяет использовать объекты разных классов с общим интерфейсом. Это означает, что методы могут работать с объектами разных типов, при условии, что эти объекты поддерживают общий интерфейс.
Пример:
   class Cat:
       def speak(self):
           return "Мяу!"

   class Dog:
       def speak(self):
           return "Гав!"

   def animal_speak(animal):
       print(animal.speak())

   my_cat = Cat()
   my_dog = Dog()

   animal_speak(my_cat)  # Выведет "Мяу!"
   animal_speak(my_dog)  # Выведет "Гав!"

SOLID - это аббревиатура, представляющая пять основных принципов объектно-ориентированного программирования и дизайна. 

Вот как эти принципы могут быть использованы в Python:
1. Принцип единственной ответственности (Single Responsibility Principle - SRP):
Согласно SRP, класс должен иметь только одну причину для изменения. 
В Python это может быть реализовано путем создания небольших и узкоспециализированных классов, каждый из которых отвечает за выполнение конкретной задачи.

2. Принцип открытости/закрытости (Open/Closed Principle - OCP):
OCP, предложенный Бертраном Мейером, утверждает, что классы должны быть открыты для расширения, но закрыты для модификации. 
В Python это может быть достигнуто путем использования наследования и полиморфизма для расширения поведения классов.

3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP):
LSP утверждает, что объекты должны быть заменяемыми своими подтипами без изменения корректности программы. 
Если в Python класс нарушает LSP, это может привести к неожиданным результатам при использовании этого класса и его подклассов.

4. Принцип разделения интерфейсов (Interface Segregation Principle - ISP):
ISP гласит, что клиенты не должны зависеть от интерфейсов, которые они не используют. 
В Python это означает, что следует создавать более мелкие интерфейсы, соответствующие конкретным потребностям.

5. Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
DIP утверждает, что классы должны зависеть от абстракций, а не от конкретных реализаций. 
В Python это означает использование интерфейсов, абстрактных классов и внедрение зависимостей для управления зависимостями между классами.